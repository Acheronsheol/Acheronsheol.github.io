[{"title":"Java环境变量配置","url":"/2022/03/20/Java环境变量配置/","content":"## Windows设置\n\n### 全局变量\n\nJAVA_HOME  --- %JDK路径%  \n如果安装多个JDK版本 可以专门设置该JDK的变量路径 例如  \nJAVA8_HOME --- %JDK8路径%  \nJAVA_HOME  --- %JAVA8_HOME%  \nPath     --- %JAVA_HOME%\\bin  \nCLASSPATH  --- .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;  \n\n### 命令行局部变量\n示例脚本1\n``` powershell\n@echo off  \nset JAVA_HOME=%JAVA8_HOME%\nset PATH=%JAVA_HOME%\\bin;\nset CLASSPATH=.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\njava -version\npause\n```\n示例脚本2\n``` powershell\n@echo off  \nsetx JAVA_HOME=%JAVA8_HOME%\nsetx PATH=%JAVA_HOME%\\bin;\nsetx CLASSPATH=.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\njava -version\npause\n```\nset用于设置临时变量  \nsetx用于设置用户变量和系统变量，设置完后不会立即生效，如要立即生效需要使用WMIC：\n``` powershell\nwmic ENVIRONMENT where \"name='path' and username='<SYSTEM>'\" set VariableValue='%path%;C:\\'  \n```\n\n## Linux设置\n\n### 全局变量\n在 /etc/profile 文件中添加以下变量\n``` sh\nexport JAVA8_HOME=/usr/java/jdk1.8.0_321\nexport JAVA17_HOME=/usr/java/jdk-17.0.2\nexport JAVA_HOME=$JAVA8_HOME\nexport PATH=$JAVA_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n```\n添加后执行`source /etc/profile`进行设置生效\n### 命令行局部变量\n``` sh\n#!/bin/sh \nexport JAVA_HOME=$JAVA17_HOME\nexport PATH=$JAVA_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\njava -version\n```","categories":["Java"]},{"title":"RxJava用法(2)","url":"/2022/03/02/RxJava用法-2/","content":"## Rx背压\n问题：在异步情况中，被观察者发送事件的速率和观察者接收事件的速率不一样，会导致缓冲区溢&oom  \n对策：背压策略（back pressure strategy）————控制事件流速  \n原理：\n* 反馈控制：被观察者根据观察者接收事件的能力发送事件\n* 响应式拉取：根据观察者自身情况接收事件\n* 缓冲区：对超出缓冲区的事件进行丢弃，覆盖，报错\n\n具体使用：Flowable  \n在flowable用法中，被观察者变成了Flowable类，观察者变成了Subscriber类,其他用法和规则不变\n\n1. 响应式拉取（控制观察者）\n![avatar](/images/blog/rxjava/响应式拉取.png)\n``` java\nFlowable.create(new FlowableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(FlowableEmitter<Integer> emitter) throws Exception {\n                Log.d(\"TAG\", \"发送事件 1\");\n                emitter.onNext(1);\n                Log.d(\"TAG\", \"发送事件 2\");\n                emitter.onNext(2);\n                Log.d(\"TAG\", \"发送事件 3\");\n                emitter.onNext(3);\n                Log.d(\"TAG\", \"发送完成\");\n                emitter.onComplete();\n            }\n        }, BackpressureStrategy.ERROR)\n                .subscribeOn(Schedulers.io()) // 设置被观察者在io线程中进行\n                .observeOn(AndroidSchedulers.mainThread()) // 设置观察者在主线程中进行\n                .subscribe(new Subscriber<Integer>() {\n                    // 步骤2：创建观察者 =  Subscriber & 建立订阅关系\n                    @Override\n                    public void onSubscribe(Subscription s) {\n                        // 对比Observer传入的Disposable参数，Subscriber此处传入的参数 = Subscription\n                        // 相同点：Subscription参数具备Disposable参数的作用，\n                        // 即Disposable.dispose()切断连接, 同样的调用Subscription.cancel()切断连接\n                        // 不同点：Subscription增加了void request(long n)\n                        // 作用：决定观察者能够接收多少个事件\n                        // 如设置了s.request(3)，这就说明观察者能够接收3个事件（多出的事件存放在缓存区）\n                        // 官方默认推荐使用Long.MAX_VALUE，即s.request(Long.MAX_VALUE);\n                        Log.d(\"TAG\", \"onSubscribe\");\n                        s.request(3);\n                        /**如果在异步的情况中request（）没有参数，则认为观察者不接受事件\n                         * 被观察者可以继续发送事件存到缓存区（缓存区大小=128）\n                         * */\n                    }\n                    @Override\n                    public void onNext(Integer integer) {\n                        Log.d(\"TAG\", \"接收到了事件\" + integer);\n                    }\n                    @Override\n                    public void onError(Throwable t) {\n                        Log.w(\"TAG\", \"onError: \", t);\n                    }\n                    @Override\n                    public void onComplete() {\n                        Log.d(\"TAG\", \"onComplete\");\n                    }\n                });\n```\n2.反馈控制（控制被观察者）\n![avatar](/images/blog/rxjava/反馈控制.png)\n在反馈控制中，同步和异步是不同的，先介绍反馈控制的同步实现方法\n * 反馈控制实现（同步）\n ``` java\n Flowable.create(new FlowableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(FlowableEmitter<Integer> emitter) throws Exception {\n                // 调用emitter.requested()获取当前观察者需要接收的事件数量\n                long n = emitter.requested();\n                Log.d(TAG, \"观察者可接收事件\" + n);\n                // 根据emitter.requested()的值，即当前观察者需要接收的事件数量来发送事件\n                for (int i = 0; i < n; i++) {\n                    Log.d(TAG, \"发送了事件\" + i);\n                    emitter.onNext(i);\n                }\n            }\n        }, BackpressureStrategy.ERROR)\n                .subscribe(new Subscriber<Integer>() {\n                    @Override\n                    public void onSubscribe(Subscription s) {\n                        Log.d(TAG, \"onSubscribe\");\n                        // 设置观察者每次能接受10个事件\n                        s.request(10);\n                    }\n                    @Override\n                    public void onNext(Integer integer) {\n                        Log.d(TAG, \"接收到了事件\" + integer);\n                    }\n                    @Override\n                    public void onError(Throwable t) {\n                        Log.w(TAG, \"onError: \", t);\n                    }\n                    @Override\n                    public void onComplete() {\n                        Log.d(TAG, \"onComplete\");\n                    }\n                });\n ```\n 在被观察者发送的时候，我们拿到emitter.requested()的值，这个值和观察者s.request(10)设置的值相同，为10，观察者设置的能接收多少事件，被观察者就发送多少事件\n * 反馈控制实现（异步）  \n在异步的情况下emitter.requested()的值和观察者s.request()的值不相同，即 被观察者不能根据 观察者自身接收事件的能力 控制发送事件的速度\n![avatar](/images/blog/rxjava/反馈控制异步.png)\n被观察者FlowableEmitter.requested()的返回值由RxJava内部决定，并且只会返回128,96,0三种情况\n![avatar](/images/blog/rxjava/反馈控制异步2.png)\n大概就是开始request（128），当缓冲区<=32的时候，request（96）\n\n``` java\n// 被观察者：一共需要发送500个事件，但真正开始发送事件的前提 = FlowableEmitter.requested()返回值 ≠ 0\n// 观察者：每次接收事件数量 = 48（点击按钮）\n\n        Flowable.create(new FlowableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(FlowableEmitter<Integer> emitter) throws Exception {\n                Log.d(TAG, \"观察者可接收事件数量 = \" + emitter.requested());\n                    boolean flag; //设置标记位控制\n                    // 被观察者一共需要发送500个事件\n                    for (int i = 0; i < 500; i++) {\n                        flag = false;\n                        // 若requested() == 0则不发送\n                        while (emitter.requested() == 0) {\n                            if (!flag) {\n                                Log.d(TAG, \"不再发送\");\n                                flag = true;\n                            }\n                        }\n                        // requested() ≠ 0 才发送\n                        Log.d(TAG, \"发送了事件\" + i + \"，观察者可接收事件数量 = \" + emitter.requested());\n                        emitter.onNext(i);\n                }\n            }\n        }, BackpressureStrategy.ERROR).subscribeOn(Schedulers.io()) // 设置被观察者在io线程中进行\n                .observeOn(AndroidSchedulers.mainThread()) // 设置观察者在主线程中进行\n                .subscribe(new Subscriber<Integer>() {\n                    @Override\n                    public void onSubscribe(Subscription s) {\n                        Log.d(TAG, \"onSubscribe\");\n                        mSubscription = s;\n                       // 初始状态 = 不接收事件；通过点击按钮接收事件\n                    }\n                    @Override\n                    public void onNext(Integer integer) {\n                        Log.d(TAG, \"接收到了事件\" + integer);\n                    }\n                    @Override\n                    public void onError(Throwable t) {\n                        Log.w(TAG, \"onError: \", t);\n                    }\n                    @Override\n                    public void onComplete() {\n                        Log.d(TAG, \"onComplete\");\n                    }\n                });\n\n// 点击按钮才会接收事件 = 48 / 次\nbtn = (Button) findViewById(R.id.btn);\n        btn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                mSubscription.request(48);\n                // 点击按钮 则 接收48个事件\n            }\n\n        });\n```\n* 被观察者：一共需要发送500个事件，真正开始发送事件的前提 = FlowableEmitter.requested()返回值 ≠ 0\n* 观察者：每次接收事件数量 = 48（点击按钮）\n\n 1. Flowable发送500个事件，开始RxJava内部会设置FlowableEmitter.requested()返回128，没有点击btn，所以Subscriber默认接收的数量为0，这128个事件被存放到缓冲区，Flowable还有（500-128=372）个事件\n 2. 点击btn，Subscriber对象可以接收48个事件，此时缓存区是（128-48=80），Subscriber对象处理了48个对象，Flowable还是（500-128=372）个事件\n 3. 再次点击，Subscriber可以接收（48+48=96）个事件，缓冲区（128-48-48=32）， 此时缓冲区满足<=32条件，RxJava内部调用request（96），Flowable（500-128-96=276），缓存区（32+96=128），剩下的以此类推，就完整的完成了反馈控制的异步展示\n* 缓冲区  \n在创建Flowable的时候，会传入第二个参数，BackpresureStrategy.ERROR 直接传入参数即可\n![avatar](/images/blog/rxjava/缓冲区.png)\n * ERROR： 当缓冲区满了会抛出异常MissingBackpressureException\n * MISSING：当缓冲区满了会提示：QUEUE is full\n * BUFFER： 将缓存区大小设置成无限大（要注意内存，防止oom）\n * DROP：超过缓冲区的事件会被丢掉\n * LATEST： 只保留最后1个事件和第1到第128个事件，（一共129个）","categories":["Android"]},{"title":"RxJava用法(1)","url":"/2022/03/02/RxJava用法/","content":"rxjava是一个异步框架，功能和handler类似，特点是链式调用，逻辑简单。\n## 内容\n* 观察者模式\n* rxjava异步使用\n* 操作符介绍\n* rxjava背压\n\n## 观察者模式\njava中的观察者模式，主要有三个关键词需要记住，被观察者（Observable），订阅（subscribe），观察者（Observer）。  \n核心思想：被观察者和观察者通过订阅产生一种关系，当被观察者发生一些改变，通知观察者，观察者对应做出相应的回应。  \n举例：小说是被观察者，读者是观察者，小说和读者之前通过subscribe产生订阅关系，小说更新了，通知读者去买新小说。  \n\n## Rx异步使用\n### 创建被观察者（Observable）\n``` java\n        Observable<String> story = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> emitter) throws Exception {\n                for (int i=1;i<4;i++){\n                    Log.d(\"TAG\",\"我是小说，我更新了第\"+i+\"季\");\n                    emitter.onNext(i+\"\");\n                }\n                emitter.onComplete();\n            }\n        });\n```\n调用Observable的create（），传入ObservableOnSubscribe对象，重写ObservableOnSubscribe对象的subscribe（），在subscribe（）中，有一个ObservableEmitter对象，这是一个发射器，调用发射器的onNext()，把被观察者（Observable）的事件发送出去。\n### 创建观察者（Observer）\n``` java\n        Observer<String> reader = new Observer<String>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(\"TAG\",\"我是读者，我和小说订阅了,小说变动后会通知我\");\n            }\n            @Override\n            public void onNext(String value) {\n                Log.d(\"TAG\",\"我是读者，我拿到了小说的新版本：\"+value+\"版本\");\n            }\n            @Override\n            public void onError(Throwable e) {\n                Log.d(\"TAG\",\"我是读者，拿小说的时候出现了问题，后面的不拿了\");\n            }\n            @Override\n            public void onComplete() {\n                Log.d(\"TAG\",\"我是读者，小说的新版本被我拿完了\");\n            }\n        };\n```\n创建Observer，直接new一个Observer重写他的四个方法:\n* onSubscribe（）：当Observer和Observable订阅的时候调用;\n* onNext（）：对Observable中的emitter.onNext（）发射出来的事件进行处理;\n* onError（）：不用多说，坏了;\n* onComplete（）：Observable发送来的事件全部处理完成，结束调用;\n\n注意onError（）和onComplete（）是互斥的，只会调用一个\n### 订阅\n``` java\n        story.observeOn(AndroidSchedulers.mainThread());\n        story.subscribeOn(Schedulers.io());\n        story.subscribe(reader);\n```\n异步实现： subscribeOn 切到后台去发送请求并解析数据，最后用 observeOn 切换到主线程更新页面。\n* story.subscribeOn(Schedulers.io());发射事件线程是io线程\n* story.observeOn(AndroidSchedulers.mainThread());处理事件线程是main\n\n本来应该是用户订阅小说，但RxJava为了保证流式API调用风格，改为了小说订阅用户，可以理解为小说记录了一个用户，更新时小说通知用户。\n\n运行结果:\n``` verilog\n2022-03-02 16:57:22.636 6289-6289/vip.izumi.androidframework D/TAG: 我是读者，我和小说订阅了,小说变动后会通知我\n2022-03-02 16:57:22.636 6289-6289/vip.izumi.androidframework D/TAG: 我是小说，我更新了第1季\n2022-03-02 16:57:22.636 6289-6289/vip.izumi.androidframework D/TAG: 我是读者，我拿到了小说的新版本：1版本\n2022-03-02 16:57:22.636 6289-6289/vip.izumi.androidframework D/TAG: 我是小说，我更新了第2季\n2022-03-02 16:57:22.636 6289-6289/vip.izumi.androidframework D/TAG: 我是读者，我拿到了小说的新版本：2版本\n2022-03-02 16:57:22.636 6289-6289/vip.izumi.androidframework D/TAG: 我是小说，我更新了第3季\n2022-03-02 16:57:22.636 6289-6289/vip.izumi.androidframework D/TAG: 我是读者，我拿到了小说的新版本：3版本\n2022-03-02 16:57:22.636 6289-6289/vip.izumi.androidframework D/TAG: 我是读者，小说的新版本被我拿完了\n```\n\n上面的三个步骤可以合起来用链式调用的方法写：\n``` java\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(ObservableEmitter<String> emitter) throws Exception {\n                for (int i=1;i<4;i++){\n                    Log.d(\"TAG\",\"我是小说，我更新了第\"+i+\"季\");\n                    emitter.onNext(i+\"\");\n                }\n                emitter.onComplete();\n            }\n        })\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribeOn(Schedulers.io())\n                .subscribe(new Observer<String>() {\n                    @Override\n                    public void onSubscribe(Disposable d) {\n                        Log.d(\"TAG\",\"我是读者，我和小说订阅了,小说变动后会通知我\");\n                    }\n                    @Override\n                    public void onNext(String value) {\n                        Log.d(\"TAG\",\"我是读者，我拿到了小说的新版本：\"+value+\"版本\");\n                    }\n                    @Override\n                    public void onError(Throwable e) {\n                        Log.d(\"TAG\",\"我是读者，拿小说的时候出现了问题，后面的不拿了\");\n                    }\n                    @Override\n                    public void onComplete() {\n                        Log.d(\"TAG\",\"我是读者，小说的新版本被我拿完了\");\n                    }\n                });\n```\n效果和上面一模一样，这种写法逻辑上更加清晰一点。\n## rxjava操作符使用\n* 创建操作符\n* 变换操作符\n* 合并操作符\n* 功能操作符\n\n### 创建操作符\n![avatar](/images/blog/rxjava/创建操作符1.png)\n作用：创建Observable，发送事件  \n* just()\n``` java\nObservable.just(\"1\",\"2\",\"3\",\"4\");\n```\n* fromArray()\n``` java\n      Integer[] numbers = {1,2,3,4};\n      Observable.fromArray(numbers);\n```\n* fromIterable()\n``` java\n        ArrayList<String> arrayList = new ArrayList<>();\n        arrayList.add(\"1\");\n        arrayList.add(\"2\");\n        arrayList.add(\"3\");\n        arrayList.add(\"4\");\n        Observable.fromIterable(arrayList);\n```\n* never():不发送任何事件\n* empty():只发送Complete事件，即emitter.complete()\n* error():发送一个异常，传入error（）中\n\n#### 延时创建：定时操作&周期性操作\n* defer()：直到有观察者（Observer ）订阅时，才动态创建被观察者对象（Observable） & 发送事件\n* timer(): 延迟指定时间后，发送1个数值0,默认是在新线程中执行\n``` java\nObservable.timer(2, TimeUnit.SECONDS) \n```\n本质 = 延迟指定时间后，调用一次 onNext(0)\n* interval()：\n``` java\n// 参数1 = 第1次延迟时间；\n// 参数2 = 间隔时间数字；\n// 参数3 = 时间单位；\nObservable.interval(3,1,TimeUnit.SECONDS)\n```\n![avatar](/images/blog/rxjava/创建操作符2.png)\n\n### 变换操作符\n![avatar](/images/blog/rxjava/变换操作符.png)\n### 合并操作符\n![avatar](/images/blog/rxjava/合并操作符.png)\n### 功能操作符\n![avatar](/images/blog/rxjava/功能操作符.png)","categories":["Android"]},{"title":"Glide用法","url":"/2022/02/28/Glide使用方法/","content":"添加依赖和访问网络权限\n``` groovy\n    implementation 'com.github.bumptech.glide:glide:4.13.0'\n    implementation 'com.github.bumptech.glide:gifdecoder:4.13.0'//glide gif解码器\n    annotationProcessor 'com.github.bumptech.glide:compiler:4.13.0'\n```\n``` xml  \n    <uses-permission android:name=\"android.permission.INTERNET\" /> \n```\n## 常用的方法\n### 加载图片到ImageView\n``` java\nGlide.with(Context context).load(Strint url).into(ImageView imageView);\n```\n### 各种形式的图片加载到ImageView\n``` java\n// 加载本地图片\nFile file = new File(getExternalCacheDir() + \"/image.jpg\");\nGlide.with(this).load(file).into(imageView);\n\n// 加载应用资源\nint resource = R.drawable.image;\nGlide.with(this).load(resource).into(imageView);\n\n// 加载二进制流\nbyte[] image = getImageBytes();\nGlide.with(this).load(image).into(imageView);\n\n// 加载Uri对象\nUri imageUri = getImageUri();\nGlide.with(this).load(imageUri).into(imageView);\n```\n### 加载带有占位图\n占位图目的为在目的图片还未加载出来的时候，提前展示给用户的一张图片；\n``` java\nGlide.with(this).load(url).placeholder(R.drawable.loading).into(imageView);\n```\n### 加载失败 放置占位符\n``` java\nGlide.with(this).load(url).placeholder(R.drawable.loading).error(R.drawable.error)\n     .diskCacheStrategy(DiskCacheStrategy.NONE)//关闭Glide的硬盘缓存机制\n     .into(imageView);\n\n//DiskCacheStrategy.NONE： 表示不缓存任何内容。\n//DiskCacheStrategy.SOURCE： 表示只缓存原始图片。\n//DiskCacheStrategy.RESULT： 表示只缓存转换过后的图片（默认选项）。\n//DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。\n```\n### 加载指定格式的图片--指定为静止图片\n``` java\nGlide.with(this)\n     .load(url)\n     .asBitmap()//只加载静态图片，如果是git图片则只加载第一帧。\n     .placeholder(R.drawable.loading)\n     .error(R.drawable.error)\n     .diskCacheStrategy(DiskCacheStrategy.NONE)\n     .into(imageView);\n```\n### 加载动态图片\n``` java\nGlide.with(this)\n     .load(url)\n     .asGif()//加载动态图片，若现有图片为非gif图片，则直接加载错误占位图。\n     .placeholder(R.drawable.loading)\n     .error(R.drawable.error)\n     .diskCacheStrategy(DiskCacheStrategy.NONE)\n     .into(imageView);\n```\n### 加载指定大小的图片\n``` java\nGlide.with(this)\n     .load(url)\n     .placeholder(R.drawable.loading)\n     .error(R.drawable.error)\n     .diskCacheStrategy(DiskCacheStrategy.NONE)\n     .override(100, 100)//指定图片大小\n     .into(imageView);\n```\n### 关闭硬盘的缓存\n``` java\nGlide.with(this)\n     .load(url)\n     .diskCacheStrategy(DiskCacheStrategy.NONE)     //关闭硬盘缓存操作\n     .into(imageView);\n     \n//其他参数表示：\n//DiskCacheStrategy.NONE： 表示不缓存任何内容。\n//DiskCacheStrategy.SOURCE： 表示只缓存原始图片。\n//DiskCacheStrategy.RESULT： 表示只缓存转换过后的图片（默认选项）。\n//DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。\n```\n### 当引用的 url 存在 token 时解决方法-->重写 Glide 的 GlideUrl 方法\n``` java\npublic class MyGlideUrl extends GlideUrl {\n\n    private String mUrl;\n\n    public MyGlideUrl(String url) {\n        super(url);\n        mUrl = url;\n    }\n\n    @Override\n    public String getCacheKey() {\n        return mUrl.replace(findTokenParam(), \"\");\n    }\n\n    private String findTokenParam() {\n        String tokenParam = \"\";\n        int tokenKeyIndex = mUrl.indexOf(\"?token=\") >= 0 ? mUrl.indexOf(\"?token=\") : mUrl.indexOf(\"&token=\");\n        if (tokenKeyIndex != -1) {\n            int nextAndIndex = mUrl.indexOf(\"&\", tokenKeyIndex + 1);\n            if (nextAndIndex != -1) {\n                tokenParam = mUrl.substring(tokenKeyIndex + 1, nextAndIndex + 1);\n            } else {\n                tokenParam = mUrl.substring(tokenKeyIndex);\n            }\n        }\n        return tokenParam;\n    }\n\n}\n```\n然后加载图片的方式为：\n``` java\nGlide.with(this).load(new MyGlideUrl(url)).into(imageView);\n```\n### 利用Glide将图片加载到不同控件或加载成不同使用方式\n1. 拿到图片实例\n\n``` java\n//1、通过自己构造 target 可以获取到图片实例\nSimpleTarget<GlideDrawable> simpleTarget = new SimpleTarget<GlideDrawable>() {\n    @Override\n    public void onResourceReady(GlideDrawable resource, GlideAnimation glideAnimation) {\n        imageView.setImageDrawable(resource);\n    }\n};\n\n//2、将图片实例记载到指定的imageview上，也可以做其他的事情\npublic void loadImage(View view) {\n    String url = \"http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg\";\n    Glide.with(this)\n         .load(url)\n         .into(simpleTarget);\n}\n``` \n2. 将图片加载到任何位置\n\n``` java\n/*\n*将图片加载为控件背景\n*/\npublic class MyLayout extends LinearLayout {\n\n    private ViewTarget<MyLayout, GlideDrawable> viewTarget;\n\n    public MyLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        viewTarget = new ViewTarget<MyLayout, GlideDrawable>(this) {\n            @Override\n            public void onResourceReady(GlideDrawable resource, GlideAnimation glideAnimation) {\n                MyLayout myLayout = getView();\n                myLayout.setImageAsBackground(resource);\n            }\n        };\n    }\n\n    public ViewTarget<MyLayout, GlideDrawable> getTarget() {\n        return viewTarget;\n    }\n\n    public void setImageAsBackground(GlideDrawable resource) {\n        setBackground(resource);\n    }\n\n}\n\n//引用图片到指定控件作为背景\npublic class MainActivity extends AppCompatActivity {\n\n    MyLayout myLayout;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        myLayout = (MyLayout) findViewById(R.id.background);\n    }\n\n    public void loadImage(View view) {\n        String url = \"http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg\";\n        Glide.with(this)\n             .load(url)\n             .into(myLayout.getTarget());\n    }\n\n}\n```\n### Glide 实现预加载\n``` java\n//a、预加载代码\nGlide.with(this)\n     .load(url)\n     .diskCacheStrategy(DiskCacheStrategy.SOURCE)\n     .preload();\n\n//preload() 有两种重载\n // 1、带有参数的重载,参数作用是设置预加载的图片大小；\n//2、不带参数的表示加载的图片为原始尺寸；\n\n//b、使用预加载的图片\nGlide.with(this)\n     .load(url)\n     .diskCacheStrategy(DiskCacheStrategy.SOURCE)\n     .into(imageView);\n```\n切记：diskCacheStrategy() 方法内必须设置参数为：“ DiskCacheStrategy.SOURCE ”，否则可能预加载失败，导致显示图片时，需要重新加载。  \n### Glide 实现图片下载\n使用 downloadOnly(int width, int height) 或 downloadOnly(Y target) 方法替代 into(view) 方法。\n``` java\npublic void downloadImage(View view) {\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                String url = \"http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg\";\n                final Context context = getApplicationContext();\n                FutureTarget<File> target = Glide.with(context)\n                                                 .load(url)\n                                                 .downloadOnly(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);\n                final File imageFile = target.get();\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        Toast.makeText(context, imageFile.getPath(), Toast.LENGTH_LONG).show();\n                    }\n                });\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }).start();\n}\n```\n1. 有两个参数的 downloadOnly(int width, int height) 方法表示指定下载尺寸，用于在子线程内进行下载；\n2. 一个参数的 downloadOnly(Y target) 方法 在主线程内进行下载\n3. target.get() 方法可以获取到下载文件保存路径；\n\n使用下载完的图片的方式\n``` java\npublic void loadImage(View view) {\n    String url = \"http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg\";\n    Glide.with(this)\n            .load(url)\n            .diskCacheStrategy(DiskCacheStrategy.SOURCE)\n            .into(imageView);\n}\n```\n注意： diskCacheStrategy() 方法的参数应该为 DiskCacheStrategy.SOURCE 或者 DiskCacheStrategy.ALL否则可能导致加载图片到控件的时候，需要重新加载。\n### 监听 Glide 加载的状态\n``` java\npublic void loadImage(View view) {\n    String url = \"http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg\";\n    Glide.with(this)\n            .load(url)\n            .listener(new RequestListener<String, GlideDrawable>() {\n                @Override\n                public boolean onException(Exception e, String model, Target<GlideDrawable> target,\n                    boolean isFirstResource) {\n                    return false;\n                }\n\n                @Override\n                public boolean onResourceReady(GlideDrawable resource, String model,\n                    Target<GlideDrawable> target, boolean isFromMemoryCache, boolean isFirstResource) {\n                    return false;\n                }\n            })\n            .into(imageView);\n```\n1. onException() 方法表示加载失败，onResourceReady() 表示加载成功；\n2. 每个方法都有一个 boolean 的返回值，false表示未处理、true 表示处理。\n\n### Glide 的图形变换功能\n1. 禁用图形变换功能\n\n``` java\nGlide.with(this)\n     .load(url)\n     .dontTransform()\n     .into(imageView);\n```\n这个方法时全局的，导致其他地方的图片也不可进行图形变换了。  \n\n修改方法: 通过 override() 方法设置大小\n``` java\nGlide.with(this)\n     .load(url)\n     .override(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)\n     .into(imageView);\n```\n2. 简单的图形变换\n\n通过 centerCrop()方法 按照原始的长宽比充满全屏和 fitCenter() 方法 对原图的中心区域进行裁剪对图片进行相关设置。\n\n``` java\nGlide.with(this)\n     .load(url)\n     .centerCrop()\n     .into(imageView);\n\nGlide.with(this)\n     .load(url)\n     .fitCenter()\n     .into(imageView);\n```\n3. override() 方法与 centerCrop() 方法配合使用\n\n``` java\nString url = \"http://cn.bing.com/az/hprichbg/rb/AvalancheCreek_ROW11173354624_1920x1080.jpg\";\nGlide.with(this)\n     .load(url)\n     .override(500, 500)\n     .centerCrop()\n     .into(imageView);\n```\n4. 复杂的图像变换\n\n首先需要再引入一个 第三方框架 。\n``` java\ndependencies {\n    implementation 'jp.wasabeef:glide-transformations:3.3.0'\n    // If you want to use the GPU Filters\n    implementation 'jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1'\n}\n```\n部分样例\n\n图片虚化\n``` java\nGlide.with(this)\n     .load(url)\n     .bitmapTransform(new BlurTransformation(this))\n     .into(imageView);\n```\n图片黑白化\n``` java\nGlide.with(this)\n     .load(url)\n     .bitmapTransform(new GrayscaleTransformation(this))\n     .into(imageView);\n```\n多个属性同时使用\n``` java\nGlide.with(this)\n     .load(url)\n     .bitmapTransform(new BlurTransformation(this), new GrayscaleTransformation(this))\n     .into(imageView);\n```\n还有更多的好玩的属性，请到框架官网查看：https://github.com/wasabeef/glide-transformations","categories":["Android"]},{"title":"Retrofit用法","url":"/2022/02/26/Retrofit用法/","content":"Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装，网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责 网络请求接口的封装\n## 添加依赖\n``` groovy\n    implementation 'com.squareup.retrofit2:retrofit:2.9.0'//\n    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'//retrofit gson支持库\n    implementation 'com.squareup.retrofit2:adapter-rxjava2:2.9.0'//retrofit rxJava支持库\n    \n    implementation 'com.google.code.gson:gson:2.8.9'//gson\n```\n## 创建接口\nRetrofit将 Http请求 抽象成 Java接口：采用 注解 描述网络请求参数 和配置网络请求参数\n``` java\npublic interface GetRequest_Interface {\n\n    @GET(\"openapi.do?keyfrom=abc&key=2032414398&type=data&doctype=json&version=1.1&q=car\")\n    Call<Reception> getCall(@Field(\"name\") String name);\n    \n    // @GET注解的作用:采用Get方法发送网络请求\n    // getCall() = 接收网络请求数据的方法\n    // 其中返回类型为Call<*>，*是接收数据的类（即上面定义的Translation类）\n    // 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call<ResponseBody>\n    \n}\n```\n## 创建Retrofit实例\n``` java\n  Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"http://fanyi.youdao.com/\") //设置网络请求的Url地址\n                .addConverterFactory(GsonConverterFactory.create()) //设置数据解析器\n                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                .build();\n```\n## 发送请求\n``` java\n        // 创建 网络请求接口 的实例\n        GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);\n        //对 发送请求 进行封装\n        Call<ResponseBody> call = request.getCall(\"\");\n        \n        //异步请求\n        call.enqueue(new Callback<ResponseBody>() {\n            //请求成功时回调\n            @Override\n            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {\n                //请求处理,输出结果\n                try {\n                    Log.d(TAG, \"onResponse: \" + response.body().string());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            //请求失败时候的回调\n            @Override\n            public void onFailure(Call<ResponseBody> call, Throwable throwable) {\n                Log.d(TAG, \"onFailure: \");\n            }\n        });\n        //同步请求\n        try {\n            Response<ResponseBody> response = call.execute();\n            Log.d(TAG, \"Sync: \" + response.body().string());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n```\n## 注解\n### 网络请求方法\n1.@GET、@POST、@PUT、@DELETE、@HEAD分别对应 HTTP中的网络请求方式  \n2.@HTTP替换@GET、@POST、@PUT、@DELETE、@PATH、@HEAD、@OPTIONS注解的作用 及 更多功能拓展\n具体使用：通过属性method、path、hasBody进行设置\n\n``` java\n    /**\n     * method：网络请求的方法（区分大小写）\n     * path：网络请求地址路径\n     * hasBody：是否有请求体\n     */\n    @HTTP(method = \"GET\", path = \"blog/{id}\", hasBody = false)\n    Call<ResponseBody> getCall(@Path(\"id\") int id);\n    // {id} 表示是一个变量\n    // method 的值 retrofit 不会做处理，所以要自行保证准确\n```\n### 标记\n1. @FormUrlEncoded 请求体是一个Form表单  \n表示发送form-encoded的数据，每个键值对需要用@Filed来注解键名，随后的对象需要提供值。  \n2. @Multipart 请求体是一个支持文件上传的Form表单  \n表示发送form-encoded的数据（适用于 有文件 上传的场景），每个键值对需要用@Part来注解键名，随后的对象需要提供值。  \n3. @Streaming 返回的数据以流的形式返回 用于返回数据较大的场景 (如果没有使用该注解，默认把数据全部载入内存，之后存取数据也是从内存中读取)\n\n``` java\npublic interface GetRequest_Interface {\n        /**\n         *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）\n         * <code>Field(\"username\")</code> 表示将后面的 <code>String name</code> 中name的取值作为 username 的值\n         */\n        @POST(\"/form\")\n        @FormUrlEncoded\n        Call<ResponseBody> testFormUrlEncoded1(@Field(\"username\") String name, @Field(\"age\") int age);\n         \n        /**\n         * {@link Part} 后面支持三种类型，{@link RequestBody}、{@link okhttp3.MultipartBody.Part} 、任意类型\n         * 除 {@link okhttp3.MultipartBody.Part} 以外，其它类型都必须带上表单字段({@link okhttp3.MultipartBody.Part} 中已经包含了表单字段的信息)，\n         */\n        @POST(\"/form\")\n        @Multipart\n        Call<ResponseBody> testFileUpload1(@Part(\"name\") RequestBody name, @Part(\"age\") RequestBody age, @Part MultipartBody.Part file);\n\n}\n```\n\n### 网络请求参数\n1. @Header & @Headers  \n添加请求头 & 添加不固定的请求头\n``` java\n// @Header\n@GET(\"user\")\nCall<User> getUser(@Header(\"Authorization\") String authorization)\n\n// @Headers\n@Headers(\"Authorization: authorization\")\n@GET(\"user\")\nCall<User> getUser()\n\n// 以上的效果是一致的。\n// 区别在于使用场景和使用方式\n// 1. 使用场景：@Header用于添加不固定的请求头，@Headers用于添加固定的请求头\n// 2. 使用方式：@Header作用于方法的参数；@Headers作用于方法\n```\n2. @Body  \n以 Post方式 传递 自定义数据类型 给服务器,如果提交的是一个Map，那么作用相当于 @Field,不过Map要经过 FormBody.Builder 类处理成为符合 Okhttp 格式的表单，如：\n``` java\nFormBody.Builder builder = new FormBody.Builder();\nbuilder.add(\"key\",\"value\");\n```\n3. @Field & @FieldMap  \n发送 Post请求 时提交请求的表单字段,与 @FormUrlEncoded 注解配合使用\n``` java\npublic interface GetRequest_Interface {\n        /**\n         *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）\n         * <code>Field(\"username\")</code> 表示将后面的 <code>String name</code> 中name的取值作为 username 的值\n         */\n        @POST(\"/form\")\n        @FormUrlEncoded\n        Call<ResponseBody> testFormUrlEncoded1(@Field(\"username\") String name, @Field(\"age\") int age);\n\n/**\n         * Map的key作为表单的键\n         */\n        @POST(\"/form\")\n        @FormUrlEncoded\n        Call<ResponseBody> testFormUrlEncoded2(@FieldMap Map<String, Object> map);\n\n}\n```\n4. @Part & @PartMap  \n发送 Post请求 时提交请求的表单字段,与@Field的区别：功能相同，但携带的参数类型更加丰富，包括数据流，所以适用于 有文件上传 的场景,与 @Multipart 注解配合使用\n``` java\npublic interface GetRequest_Interface {\n\n          /**\n         * {@link Part} 后面支持三种类型，{@link RequestBody}、{@link okhttp3.MultipartBody.Part} 、任意类型\n         * 除 {@link okhttp3.MultipartBody.Part} 以外，其它类型都必须带上表单字段({@link okhttp3.MultipartBody.Part} 中已经包含了表单字段的信息)，\n         */\n        @POST(\"/form\")\n        @Multipart\n        Call<ResponseBody> testFileUpload1(@Part(\"name\") RequestBody name, @Part(\"age\") RequestBody age, @Part MultipartBody.Part file);\n\n        /**\n         * PartMap 注解支持一个Map作为参数，支持 {@link RequestBody } 类型，\n         * 如果有其它的类型，会被{@link retrofit2.Converter}转换，如后面会介绍的 使用{@link com.google.gson.Gson} 的 {@link retrofit2.converter.gson.GsonRequestBodyConverter}\n         * 所以{@link MultipartBody.Part} 就不适用了,所以文件只能用<b> @Part MultipartBody.Part </b>\n         */\n        @POST(\"/form\")\n        @Multipart\n        Call<ResponseBody> testFileUpload2(@PartMap Map<String, RequestBody> args, @Part MultipartBody.Part file);\n\n        @POST(\"/form\")\n        @Multipart\n        Call<ResponseBody> testFileUpload3(@PartMap Map<String, RequestBody> args);\n}\n```\n5.@Query和@QueryMap  \n用于 @GET 方法的查询参数（Query = Url 中 ‘?’ 后面的 key-value）  \n如：url = http://www.println.net/?cate=android，其中，Query = cate  \n配置时只需要在接口方法中增加一个参数即可：\n``` java\n   @GET(\"/\")    \n   Call<String> cate(@Query(\"cate\") String cate);\n\n\t// 其使用方式同 @Field与@FieldMap，这里不作过多描述\n```\n6. @Path  \nURL地址的缺省值\n``` java\npublic interface GetRequest_Interface {\n\n        @GET(\"users/{user}/repos\")\n        Call<ResponseBody>  getBlog（@Path(\"user\") String user ）;\n        // 访问的API是：https://api.github.com/users/{user}/repos\n        // 在发起请求时， {user} 会被替换为方法的第一个参数 user（被@Path注解作用）\n    }\n```\n7. @Url  \n直接传入一个请求的 URL变量 用于URL设置\n``` java\npublic interface GetRequest_Interface {\n\n        @GET\n        Call<ResponseBody> testUrlAndQuery(@Url String url, @Query(\"showAll\") boolean showAll);\n       // 当有URL注解时，@GET传入的URL就可以省略\n       // 当GET、POST...HTTP等方法中没有设置Url时，则必须使用 {@link Url}提供\n\n}\n```","tags":["HTTP"],"categories":["Android"]},{"title":"关于MediaType","url":"/2022/02/26/关于MediaType/","content":"## MediaType对象解析\nMediaType：决定浏览器将以什么形式、什么编码对资源进行解析  \nContent-Type：也属于MediaType媒体类型，主要用于在请求头中指定资源的MediaType\n\nMediaType对象包含了三种信息：type 、subtype以及charset  \n比如 `\"text/x-markdown; charset=utf-8\"`\n* type值是text，表示是文本这一大类；\n* subtype是/后面的x-markdown，表示是文本这一大类下的markdown这一小类；\n* charset=utf-8 则表示采用UTF-8编码。\n\n## MediaType类型\n类型|描述\n:--:|:--:\ntext/html|HTML格式\ntext/plain|纯文本格式，空格转换为 “+” 加号，但不对特殊字符编码\ntext/html|HTML格式\ntext/plain|纯文本格式，空格转换为 “+” 加号，但不对特殊字符编码\ntext/xml|XML格式\ntext/x-markdown|Markdown格式\nimage/gif|gif图片格式\nimage/jpeg|jpg图片格式\nimage/png|png图片格式\napplication/xhtml+xml|XHTML格式\napplication/xml|XML数据格式\napplication/json|用来告诉服务端，消息主体是序列化后的JSON字符串\napplication/pdf|pdf格式\napplication/msword|Word文档格式\napplication/octet-stream|二进制流数据（如常见的文件下载）\napplication/x-www-form-urlencoded|参数为键值对形式，在发送前编码所有字符（默认）。浏览器的原生 <form encType=”” 表单提交类型，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据\nmultipart/form-data|不对字符编码，发送大量二进制数据或包含non-ASCII字符的文本,application/x-www-form-urlencoded是效率低下的（需要用更多字符表示一个non-ASCII字符）。需要设定“ <form enctype=‘multipart/form-data’”","tags":["HTTP","基础知识"]},{"title":"OkHttp用法","url":"/2022/02/25/OkHttp用法/","content":"## 基本使用\n首先记得在build.gradle 和 配置文件分别加上依赖 和 网络权限\n``` groovy\nimplementation 'com.squareup.okhttp3:okhttp:4.8.1'\n```\n``` xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\nOkHttp采用建造者模式设计，使用很方便\n\n### 异步Get请求\n\n- 构造Request对象；\n- new OkHttpClient;\n- 通过前两步中的对象构建Call对象；\n- 通过Call#enqueue(Callback)方法来提交异步请求；\n\n``` java\n        String url = \"http://wwww.baidu.com\";\n        final Request request = new Request.Builder()\n                .url(url)\n                .get()//默认就是GET请求，可以不写\n                .build();\n\n        //创建一个http客户端对象\n        OkHttpClient okHttpClient = new OkHttpClient();\n        Call call = okHttpClient.newCall(request);\n\n        call.enqueue(new Callback() {\n            @Override\n            public void onFailure(@NonNull Call call, @NonNull IOException e) {\n                Log.d(TAG, \"onFailure: \");\n            }\n            @Override\n            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {\n                Log.d(TAG, \"onResponse: \" + response.body().string());\n            }\n        });\n```\n异步发起的请求会被加入到 Dispatcher 中的 runningAsyncCalls双端队列中通过线程池来执行。\n\n### 同步Get请求\n前面几个步骤和异步方式一样，只是最后一部是通过 Call#execute() 来提交请求，注意这种方式会阻塞调用线程，所以在Android中应放在子线程中执行，否则有可能引起ANR异常，Android3.0 以后已经不允许在主线程访问网络。\n``` java\n        String url = \"http://wwww.baidu.com\";\n        //创建一个http客户端对象\n        final Request request = new Request.Builder()\n                .url(url)\n                .get()//默认就是GET请求，可以不写\n                .build();\n\n        //创建一个http客户端对象\n        OkHttpClient okHttpClient = new OkHttpClient();\n        Call call = okHttpClient.newCall(request);\n\n        //Android3.0 以后已经不允许在主线程访问网络。\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Response response = call.execute();\n                    Log.d(TAG, \"run:\"+response.body().string());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n```\n### POST方式提交String\n这种方式与前面的区别就是在构造Request对象时，需要多构造一个RequestBody对象，用它来携带我们要提交的数据。在构造 RequestBody 需要指定MediaType，用于描述请求/响应 body 的内容类型，关于 MediaType 的更多信息可以查看 RFC 2045.\n``` java\n        String url = \"http://wwww.baidu.com\";\n        MediaType mediaType = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n        String requestBody = \"I am quanzi\";\n        final Request request = new Request.Builder()\n                .url(url)\n                .post(RequestBody.Companion.create(requestBody,mediaType))\n                .build();\n\n        //创建一个http客户端对象\n        OkHttpClient okHttpClient = new OkHttpClient();\n        Call call = okHttpClient.newCall(request);\n\n        call.enqueue(new Callback() {\n            @Override\n            public void onFailure(@NonNull Call call, @NonNull IOException e) {\n                Log.d(TAG, \"onFailure: \");\n            }\n            @Override\n            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {\n                Log.d(TAG, \"onResponse: \" + response.body().string());\n            }\n        });\n```\n### POST方式提交流\n``` java\n        RequestBody requestBody = new RequestBody() {\n            @Nullable\n            @Override\n            public MediaType contentType() {\n                return MediaType.parse(\"text/x-markdown; charset=utf-8\");\n            }\n\n            @Override\n            public void writeTo(@NonNull BufferedSink bufferedSink) throws IOException {\n                bufferedSink.writeUtf8(\"I am quanzi.\");\n            }\n        };\n\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/markdown/raw\")\n                .post(requestBody)\n                .build();\n\n        //创建一个http客户端对象\n        OkHttpClient okHttpClient = new OkHttpClient();\n        Call call = okHttpClient.newCall(request);\n\n        call.enqueue(new Callback() {\n            @Override\n            public void onFailure(@NonNull Call call, @NonNull IOException e) {\n                Log.d(TAG, \"onFailure: \");\n            }\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                Log.d(TAG, response.protocol() + \" \" +response.code() + \" \" + response.message());\n                Headers headers = response.headers();\n                for (int i = 0; i < headers.size(); i++) {\n                    Log.d(TAG, headers.name(i) + \":\" + headers.value(i));\n                }\n                Log.d(TAG, \"onResponse: \" + response.body().string());\n            }\n        });\n```\n### POST方式提交文件\n``` java\n        MediaType mediaType = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n        File file = new File(\"test.md\");\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/markdown/raw\")\n                .post(RequestBody.Companion.create(file,mediaType))\n                .build();\n\n        OkHttpClient okHttpClient = new OkHttpClient();\n        okHttpClient.newCall(request).enqueue(new Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                Log.d(TAG, \"onFailure: \" + e.getMessage());\n            }\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                Log.d(TAG, response.protocol() + \" \" +response.code() + \" \" + response.message());\n                Headers headers = response.headers();\n                for (int i = 0; i < headers.size(); i++) {\n                    Log.d(TAG, headers.name(i) + \":\" + headers.value(i));\n                }\n                Log.d(TAG, \"onResponse: \" + response.body().string());\n            }\n        });\n```\n### POST方式提交表单\n``` java\n        RequestBody requestBody = new FormBody.Builder()\n                .add(\"search\", \"Jurassic Park\")\n                .build();\n        Request request = new Request.Builder()\n                .url(\"https://en.wikipedia.org/w/index.php\")\n                .post(requestBody)\n                .build();\n\n        OkHttpClient okHttpClient = new OkHttpClient();\n        okHttpClient.newCall(request).enqueue(new Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                Log.d(TAG, \"onFailure: \" + e.getMessage());\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                Log.d(TAG, response.protocol() + \" \" +response.code() + \" \" + response.message());\n                Headers headers = response.headers();\n                for (int i = 0; i < headers.size(); i++) {\n                    Log.d(TAG, headers.name(i) + \":\" + headers.value(i));\n                }\n                Log.d(TAG, \"onResponse: \" + response.body().string());\n            }\n        });\n```\n### POST方式提交分块请求\nMultipartBody 可以构建复杂的请求体，与HTML文件上传形式兼容。多块请求体中每块请求都是一个请求体，可以定义自己的请求头。这些请求头可以用来描述这块请求，例如它的 Content-Disposition 。如果 Content-Length 和 Content-Type 可用的话，他们会被自动添加到请求头中。\n``` java\n        String IMGUR_CLIENT_ID = \"...\";\n        MediaType MEDIA_TYPE_PNG = MediaType.parse(\"image/png\");\n\n        // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image\n        MultipartBody body = new MultipartBody.Builder(\"AaB03x\")\n                .setType(MultipartBody.FORM)\n                .addPart(\n                        Headers.of(\"Content-Disposition\", \"form-data; name=\\\"title\\\"\"),\n                        RequestBody.create(null, \"Square Logo\"))\n                .addPart(\n                        Headers.of(\"Content-Disposition\", \"form-data; name=\\\"image\\\"\"),\n                        RequestBody.create(MEDIA_TYPE_PNG, new File(\"website/static/logo-square.png\")))\n                .build();\n\n        Request request = new Request.Builder()\n                .header(\"Authorization\", \"Client-ID \" + IMGUR_CLIENT_ID)\n                .url(\"https://api.imgur.com/3/image\")\n                .post(body)\n                .build();\n\n        OkHttpClient client = new OkHttpClient();\n        Call call = client.newCall(request);\n\n        call.enqueue(new Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n            }\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                System.out.println(response.body().string());\n            }\n        });\n```\n## 拦截器-interceptor\nOkHttp的拦截器链可谓是其整个框架的精髓，用户可传入的 interceptor 分为两类：\n①一类是全局的 interceptor，该类 interceptor 在整个拦截器链中最早被调用，通过 OkHttpClient.Builder#addInterceptor(Interceptor) 传入；\n②另外一类是非网页请求的 interceptor ，这类拦截器只会在非网页请求中被调用，并且是在组装完请求之后，真正发起网络请求前被调用，所有的 interceptor 被保存在 List<Interceptor> interceptors 集合中，按照添加顺序来逐个调用，具体可参考 RealCall#getResponseWithInterceptorChain() 方法。通过 OkHttpClient.Builder#addNetworkInterceptor(Interceptor) 传入；\n\n这里举一个简单的例子，例如有这样一个需求，我要监控App通过 OkHttp 发出的所有原始请求，以及整个请求所耗费的时间，针对这样的需求就可以使用第一类全局的 interceptor 在拦截器链头去做。\n``` java\npublic class LoggingInterceptor implements Interceptor {\n\n    private static final String TAG = \"LoggingInterceptor\";\n\n    @NonNull\n    @Override\n    public Response intercept(@NonNull Chain chain) throws IOException {\n        Request request = chain.request();\n\n        long startTime = System.currentTimeMillis();\n        Log.d(TAG, String.format(\"Sending request %s on %s%n%s\", request.url(), chain.connection(), request.headers()));\n\n        Response response = chain.proceed(request);\n\n        long endTime = System.nanoTime();\n        Log.d(TAG, String.format(\"Received response for %s in %.1fms%n%s\", response.request().url(), (endTime - startTime) / 1e6d, response.headers()));\n\n        return response;\n    }\n\n}\n```\n``` java\n        OkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .addInterceptor(new LoggingInterceptor())\n                .build();\n\n        Request request = new Request.Builder()\n                .url(\"http://www.publicobject.com/helloworld.txt\")\n                .header(\"User-Agent\", \"OkHttp Example\")\n                .build();\n\n        okHttpClient.newCall(request).enqueue(new Callback() {\n            @Override\n            public void onFailure(@NonNull Call call, @NonNull IOException e) {\n                Log.d(TAG, \"onFailure: \" + e.getMessage());\n            }\n            @Override\n            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {\n                ResponseBody body = response.body();\n                if (body != null) {\n                    Log.d(TAG, \"onResponse: \" + body.string());\n                    body.close();\n                }\n            }\n        });\n```\n## 其他\n1. 推荐让 OkHttpClient 保持单例，用同一个 OkHttpClient 实例来执行你的所有请求，因为每一个 OkHttpClient 实例都拥有自己的连接池和线程池，重用这些资源可以减少延时和节省资源，如果为每个请求创建一个 OkHttpClient 实例，显然就是一种资源的浪费。当然，也可以使用如下的方式来创建一个新的 OkHttpClient 实例，它们共享连接池、线程池和配置信息。\n``` java\n    OkHttpClient eagerClient = client.newBuilder()\n        .readTimeout(500, TimeUnit.MILLISECONDS)\n        .build();\n    Response response = eagerClient.newCall(request).execute();\n```\n2. 每一个Call（其实现是RealCall）只能执行一次，否则会报异常，具体参见 RealCall#execute()","tags":["HTTP"],"categories":["Android"]},{"title":"EventBus用法","url":"/2022/02/24/EventBus用法/","content":"### EventBus 简介\nEventBus是一种用于Android的事件发布-订阅总线，由GreenRobot开发，Gihub地址是：EventBus。它简化了应用程序内各个组件之间进行通信的复杂度，尤其是碎片之间进行通信的问题，可以避免由于使用广播通信而带来的诸多不便。\n\n#### 三个角色\n* Event：事件，它可以是任意类型，EventBus会根据事件类型进行全局的通知。\n* Subscriber：事件订阅者，在EventBus 3.0之前我们必须定义以onEvent开头的那几个方法，分别是onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，而在3.0之后事件处理的方法名可以随意取，不过需要加上注解@subscribe，并且指定线程模型，默认是POSTING。\n* Publisher：事件的发布者，可以在任意线程里发布事件。一般情况下，使用EventBus.getDefault()就可以得到一个EventBus对象，然后再调用post(Object)方法即可。\n\n#### 四种线程模型\nEventBus3.0有四种线程模型，分别是：\n* POSTING：默认，表示事件处理函数的线程跟发布事件的线程在同一个线程。\n* MAIN：表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。\n* BACKGROUND：表示事件处理函数的线程在后台线程，因此不能进行UI操作。如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。\n* ASYNC：表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。\n\n### EventBus 使用\n\n#### 引入依赖\n在使用之前先要引入如下依赖：\n``` groovy\nimplementation 'org.greenrobot:eventbus:3.1.1'\n```\n#### 定义事件\n然后，我们定义一个事件的封装对象。在程序内部就使用该对象作为通信的信息：\n``` java\npublic class MessageWrap {\n\n    public final String message;\n\n    public static MessageWrap getInstance(String message) {\n        return new MessageWrap(message);\n    }\n\n    private MessageWrap(String message) {\n        this.message = message;\n    }\n}\n``` \n\n#### 发布事件\n然后，我们定义一个Activity：\n``` java\n@Route(path = BaseConstants.LIBRARY_EVENT_BUS_ACTIVITY1)\npublic class EventBusActivity1 extends CommonActivity<ActivityEventBus1Binding> {\n\n    @Override\n    protected void doCreateView(Bundle savedInstanceState) {\n        // 为按钮添加添加单击事件\n        getBinding().btnReg.setOnClickListener(v -> EventBus.getDefault().register(this));\n        getBinding().btnNav2.setOnClickListener( v ->\n                ARouter.getInstance()\n                        .build(BaseConstants.LIBRARY_EVENT_BUS_ACTIVITY2)\n                        .navigation());\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        EventBus.getDefault().unregister(this);\n    }\n\n    @Subscribe(threadMode = ThreadMode.MAIN)\n    public void onGetMessage(MessageWrap message) {\n        getBinding().tvMessage.setText(message.message);\n    }\n}\n```\n这里我们当按下按钮的时候向EventBus注册监听，然后按下另一个按钮的时候跳转到拎一个Activity，并在另一个Activity发布我们输入的事件。在上面的Activity中，我们会添加一个监听的方法，即onGetMessage，这里我们需要为其加入注解Subscribe并指定线程模型为主线程MAIN。最后，就是在Activity的onDestroy方法中取消注册该Activity。\n\n下面是另一个Activity的定义，在这个Activity中，我们当按下按钮的时候从EditText中取出内容并进行发布，然后我们退出到之前的Activity，以测试是否正确监听到发布的内容。\n``` java\n@Route(path = BaseConstants.LIBRARY_EVENT_BUS_ACTIVITY2)\npublic class EventBusActivity2 extends CommonActivity<ActivityEventBus2Binding> {\n\n    @Override\n    protected void doCreateView(Bundle savedInstanceState) {\n        getBinding().btnPublish.setOnClickListener(v -> publishContent());\n    }\n\n    private void publishContent() {\n        String msg = getBinding().etMessage.getText().toString();\n        EventBus.getDefault().post(MessageWrap.getInstance(msg));\n        ToastUtils.makeToast(\"Published : \" + msg);\n    }\n}\n```\n根据测试的结果，我们的确成功地接收到了发送的信息。\n#### 黏性事件\n所谓的黏性事件，就是指发送了该事件之后再订阅者依然能够接收到的事件。使用黏性事件的时候有两个地方需要做些修改。一个是订阅事件的地方，这里我们在先打开的Activity中注册监听黏性事件：\n``` java\n@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)\npublic void onGetStickyEvent(MessageWrap message) {\n    String txt = \"Sticky event: \" + message.message;\n    getBinding().tvStickyMessage.setText(txt);\n}\n```\n另一个是发布事件的地方，这里我们在新的开的Activity中发布黏性事件。即调用EventBus的postSticky方法来发布事件：\n``` java\nprivate void publishStickyontent() {\n    String msg = getBinding().etMessage.getText().toString();\n    EventBus.getDefault().postSticky(MessageWrap.getInstance(msg));\n    ToastUtils.makeToast(\"Published : \" + msg);\n}\n```\n按照上面的模式，我们先在第一个Activity中打开第二个Activity，然后在第二个Activity中发布黏性事件，并回到第一个Activity注册EventBus。根据测试结果，当按下注册按钮的时候，会立即触发上面的订阅方法从而获取到了黏性事件。\n#### 优先级\n在Subscribe注解中总共有3个参数，上面我们用到了其中的两个，这里我们使用以下第三个参数，即priority。它用来指定订阅方法的优先级，是一个整数类型的值，默认是0，值越大表示优先级越大。在某个事件被发布出来的时候，优先级较高的订阅方法会首先接受到事件。\n\n为了对优先级进行测试，这里我们需要对上面的代码进行一些修改。这里，我们使用一个布尔类型的变量来判断是否应该取消事件的分发。我们在一个较高优先级的方法中通过该布尔值进行判断，如果未true就停止该事件的继续分发，从而通过低优先级的订阅方法无法获取到事件来证明优先级较高的订阅方法率先获取到了事件。\n\n这里有几个地方需要注意：\n\n1. 只有当两个订阅方法使用相同的ThreadMode参数的时候，它们的优先级才会与priority指定的值一致；\n2. 只有当某个订阅方法的ThreadMode参数为POSTING的时候，它才能停止该事件的继续分发。\n\n所以，根据以上的内容，我们需要对代码做如下的调整：\n``` java\n// 用来判断是否需要停止事件的继续分发\nprivate boolean stopDelivery = false;\n\n@Override\nprotected void doCreateView(Bundle savedInstanceState) {\n    // ...\n    getBinding().btnStop.setOnClickListener(v -> stopDelivery = true);\n}\n\n@Subscribe(threadMode = ThreadMode.POSTING, priority = 0)\npublic void onGetMessage(MessageWrap message) {\n    getBinding().tvMessage.setText(message.message);\n}\n\n// 订阅方法，需要与上面的方法的threadMode一致，并且优先级略高\n@Subscribe(threadMode = ThreadMode.POSTING, sticky = true, priority = 1)\npublic void onGetStickyEvent(MessageWrap message) {\n    String txt = \"Sticky event: \" + message.message;\n    getBinding().tvStickyMessage.setText(txt);\n    if (stopDelivery) {\n        // 终止事件的继续分发\n        EventBus.getDefault().cancelEventDelivery(message);\n    }\n}\n```\n即我们在之前的代码之上增加了一个按钮，用来将stopDelivery的值置为true。该字段随后将会被用来判断是否要终止事件的继续分发，因为我们需要在代码中停止事件的继续分发，所以，我们需要将上面的两个订阅方法的threadMode的值都置为ThreadMode.POSTING。\n\n按照，上面的测试方式，首先我们在当前的Activity注册监听，然后跳转到另一个Activity，发布事件并返回。第一次的时候，这里的两个订阅方法都会被触发。然后，我们按下停止分发的按钮，并再次执行上面的逻辑，此时只有优先级较高的方法获取到了事件并将该事件终止。","categories":["Android"]},{"title":"GreenDao用法","url":"/2022/02/24/GreenDao用法/","content":"## GreenDao 优点：\n* 性能高，号称Android最快的关系型数据库\n* 内存占用小\n* 库文件比较小，小于100K，编译时间低，而且可以避免65K方法限制\n* 支持数据库加密  greendao支持SQLCipher进行数据库加密\n* Sqlite采用SQLCipher数据库加密实战\n* 简洁易用的API\n\n## GreenDao 3.0使用方式\n### 添加配置\n在project build.gradle 加入\n``` groovy\nbuildscript {\n    repositories {\n        mavenCentral()//GreenDao仓库 其他源也可以\n    }\n    dependencies {\n        classpath \"com.android.tools.build:gradle:4.0.1\"\n        //GreenDao\n        classpath 'org.greenrobot:greendao-gradle-plugin:3.3.0'//GreenDao\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\n```\n在module build.gradle中添加\n``` groovy\napply plugin: 'org.greenrobot.greendao'\n//下面的是新版\nplugins {\n    id 'com.android.application'\n    id 'org.greenrobot.greendao'//GreenDao\n}\n\ngreendao {\n    schemaVersion 1//当前数据库版本\n    targetGenDir 'src/main/java'//指定设置DaoMaster 、DaoSession、Dao目录\n    daoPackage 'vip.izumi.androidframework.dao.db'//设置DaoMaster 、DaoSession、Dao包名\n}\n//依赖添加\nimplementation 'org.greenrobot:greendao:3.3.0'\n\n```\n\n### Gradle 插件配置\n比如上面想指定生成DaoMaster 、DaoSession、Dao位置\n``` groovy\ngreendao {\n    targetGenDir 'src/main/java'\n}\n```\n* schemaVersion： 数据库schema版本，也可以理解为数据库版本号\n* daoPackage：设置DaoMaster 、DaoSession、Dao包名\n* targetGenDir：设置DaoMaster 、DaoSession、Dao目录\n* targetGenDirTest：设置生成单元测试目录\n* generateTests：设置自动生成单元测试用例\n\n### 新建实体\n``` java\n@Entity\npublic class User {\n    @Id\n    private Long id;\n    private String name;\n    private int age;\n\n   //下面省去了 setter/getter\n}\n```\n\n### 实体@Entity注解\n* schema：告知GreenDao当前实体属于哪个schema\n* active：标记一个实体处于活动状态，活动实体有更新、删除和刷新方法\n* nameInDb：在数据中使用的别名，默认使用的是实体的类名\n* indexes：定义索引，可以跨越多个列\n* createInDb：标记创建数据库表\n\n### 基础属性注解\n* @Id :主键 Long型，可以通过@Id(autoincrement = true)设置自增长\n* @Property：设置一个非默认关系映射所对应的列名，默认是的使用字段名 举例：@Property (nameInDb=\"name\")\n* @NotNul：设置数据库表当前列不能为空\n* @Transient ：添加次标记之后不会生成数据库表的列\n\n### 索引注解\n* @Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束\n* @Unique：向数据库列添加了一个唯一的约束\n\n### 关系注解\n* @ToOne：定义与另一个实体（一个实体对象）的关系\n* @ToMany：定义与多个实体对象的关系\n\n## GreenDao 3.0简单实战：\n### 通过上面使用方式我们可以获取DaoMaster 、DaoSession、Dao类\n这里声明一个数据库管理者单例\n``` java\npublic class DBManager {\n    private final static String dbName = \"test_db\";\n    private static DBManager mInstance;\n    private DaoMaster.DevOpenHelper openHelper;\n    private Context context;\n\n    public DBManager(Context context) {\n        this.context = context;\n        openHelper = new DaoMaster.DevOpenHelper(context, dbName, null);\n    }\n\n    /**\n     * 获取单例引用\n     *\n     * @param context\n     * @return\n     */\n    public static DBManager getInstance(Context context) {\n        if (mInstance == null) {\n            synchronized (DBManager.class) {\n                if (mInstance == null) {\n                    mInstance = new DBManager(context);\n                }\n            }\n        }\n        return mInstance;\n    }\n}\n\n```\n### 获取可读可写数据库\n可读数据库\n``` java\n    /**\n     * 获取可读数据库\n     */\n    private SQLiteDatabase getReadableDatabase() {\n        if (openHelper == null) {\n            openHelper = new DaoMaster.DevOpenHelper(context, dbName, null);\n        }\n        SQLiteDatabase db = openHelper.getReadableDatabase();\n        return db;\n    }\n```\n可写数据库\n``` java\n    /**\n     * 获取可写数据库\n     */\n    private SQLiteDatabase getWritableDatabase() {\n        if (openHelper == null) {\n            openHelper = new DaoMaster.DevOpenHelper(context, dbName, null);\n        }\n        SQLiteDatabase db = openHelper.getWritableDatabase();\n        return db;\n    }\n```\n### 插入数据\n``` java\n /**\n     * 插入一条记录\n     *\n     * @param user\n     */\n    public void insertUser(User user) {\n        DaoMaster daoMaster = new DaoMaster(getWritableDatabase());\n        DaoSession daoSession = daoMaster.newSession();\n        UserDao userDao = daoSession.getUserDao();\n        userDao.insert(user);\n    }\n\n    /**\n     * 插入用户集合\n     *\n     * @param users\n     */\n    public void insertUserList(List<User> users) {\n        if (users == null || users.isEmpty()) {\n            return;\n        }\n        DaoMaster daoMaster = new DaoMaster(getWritableDatabase());\n        DaoSession daoSession = daoMaster.newSession();\n        UserDao userDao = daoSession.getUserDao();\n        userDao.insertInTx(users);\n    }\n```\n### 删除数据\n``` java\n    /**\n     * 删除一条记录\n     *\n     * @param user\n     */\n    public void deleteUser(User user) {\n        DaoMaster daoMaster = new DaoMaster(getWritableDatabase());\n        DaoSession daoSession = daoMaster.newSession();\n        UserDao userDao = daoSession.getUserDao();\n        userDao.delete(user);\n    }\n```\n### 更新数据\n``` java\n    /**\n     * 更新一条记录\n     *\n     * @param user\n     */\n    public void updateUser(User user) {\n        DaoMaster daoMaster = new DaoMaster(getWritableDatabase());\n        DaoSession daoSession = daoMaster.newSession();\n        UserDao userDao = daoSession.getUserDao();\n        userDao.update(user);\n    }\n```\n### 查询数据\n``` java\n    /**\n     * 查询用户列表\n     */\n    public List<User> queryUserList() {\n        DaoMaster daoMaster = new DaoMaster(getReadableDatabase());\n        DaoSession daoSession = daoMaster.newSession();\n        UserDao userDao = daoSession.getUserDao();\n        QueryBuilder<User> qb = userDao.queryBuilder();\n        List<User> list = qb.list();\n        return list;\n    }\n\n    /**\n     * 查询用户列表\n     */\n    public List<User> queryUserList(int age) {\n        DaoMaster daoMaster = new DaoMaster(getReadableDatabase());\n        DaoSession daoSession = daoMaster.newSession();\n        UserDao userDao = daoSession.getUserDao();\n        QueryBuilder<User> qb = userDao.queryBuilder();\n        qb.where(UserDao.Properties.Age.gt(age)).orderAsc(UserDao.Properties.Age);\n        List<User> list = qb.list();\n        return list;\n    }\n```\n### 测试程序\n``` java\n DBManager dbManager = DBManager.getInstance(this);\n        for (int i = 0; i < 5; i++) {\n            User user = new User();\n            user.setId(i);\n            user.setAge(i * 3);\n            user.setName(\"第\" + i + \"人\");\n            dbManager.insertUser(user);\n        }\n        List<User> userList = dbManager.queryUserList();\n        for (User user : userList) {\n            Log.e(\"TAG\", \"queryUserList--before-->\" + user.getId() + \"--\" + user.getName() +\"--\"+user.getAge());\n            if (user.getId() == 0) {\n                dbManager.deleteUser(user);\n            }\n            if (user.getId() == 3) {\n                user.setAge(10);\n                dbManager.updateUser(user);\n            }\n        }\n        userList = dbManager.queryUserList();\n        for (User user : userList) {\n            Log.e(\"TAG\", \"queryUserList--after--->\" + user.getId() + \"---\" + user.getName()+\"--\"+user.getAge());\n        }\n\n```","categories":["Android"]},{"title":"MySQL root用户解除限制","url":"/2021/12/07/MySQL-root用户解除限制/","content":"``` shell\n$ mysql -u root -p \nEnter password：{password}\n\nmysql>use mysql;\nmysql>update user set host='%' where user='root'; \nmysql>flush privileges;\nmysql>quit\n```","categories":["MySQL"]},{"title":"MultiType中实现单类型多样式布局","url":"/2021/01/31/MultiType中实现单类型多样式布局/","content":"基于 MultiType(RecyclerView多类型适配器) \n\n``` groovy  \nimplementation 'me.drakeet.multitype:multitype:3.5.0'\n```\n\n创建含有type的Bean类(type可替换为具有区分度的参数)\n\n\n``` java\npublic class ChatMsg {\n    \n    private String msg;\n    private int type;\n\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n    public String getMsg() {\n        return msg;\n    }\n\n    public void setType(int type) {\n        this.type = type;\n    }\n    public int getType() {\n        return type;\n    }\n    \n}\n```\n\n然后根据Bean类中的type值来区分布局模式\n\n``` java\npublic class ChatRoomBinderLinker implements ClassLinker<ChatMsg> {\n    @NonNull\n    @Override\n    public Class<? extends ItemViewBinder<ChatMsg, ?>> index(int position, @NonNull ChatMsg chatMsg) {\n        if (chatMsg.getType() == 1) {\n            return ChatRoomMessageBinder.class;\n        } else if(chatMsg.getType() == 2) {\n            return ChatRoomWelcomeBinder.class;\n        }\n        return ChatRoomEmptyBinder.class;\n    }\n}\n```","categories":["Android"]},{"title":"自整理Android好用的框架插件(持续更新)","url":"/2021/01/31/自整理Android好用的框架插件-持续更新/","content":"## Android Studio 插件\n\nUi Automator Viewer(APP View查看器) https://github.com/512433465/autotest_helper/\nSmallestWidth(最小宽度限定符)\nCodeGlance(代码预览)\n\n## 开发框架(引用版本为文章截止稳定最新)\n\n``` groovy\nEventBus 'org.greenrobot:eventbus:3.2.0'\nGreenDao 'org.greenrobot:greendao:3.3.0'\nGson 'com.google.code.gson:gson:2.8.6'\nRxJava 'io.reactivex.rxjava2:rxjava:2.2.19'\nRxAndroid 'io.reactivex.rxjava2:rxandroid:2.1.1'\nOkHttp 'com.squareup.okhttp3:okhttp:4.8.1'\nOkHttp(http请求跟踪) 'com.squareup.okhttp3:logging-interceptor:4.8.1'\nRetrofit 'com.squareup.retrofit2:retrofit:2.9.0'\nRetrofit-Gson 'com.squareup.retrofit2:converter-gson:2.9.0'\nRetrofit-RxJava 'com.squareup.retrofit2:adapter-rxjava2:2.9.0'\nGlide 'com.github.bumptech.glide:glide:4.11.0'\nGlide-GIF 'com.github.bumptech.glide:gifdecoder:4.11.0'\n\nImmersionBar(沉浸式状态栏) 'com.gyf.immersionbar:immersionbar:3.0.0'\nImmersionBar-Fragment 'com.gyf.immersionbar:immersionbar-components:3.0.0'\nRefreshLayout(刷新控件) 'com.scwang.smart:refresh-layout-kernel:2.0.1'\n     'com.scwang.smart:refresh-header-classics:2.0.1'//刷新控件-经典刷新加载\n     'com.scwang.smart:refresh-footer-classics:2.0.1'//刷新控件-经典刷新加载\n     'com.scwang.smart:refresh-header-material:2.0.1'//刷新控件-谷歌刷新加载\n     'com.scwang.smart:refresh-header-falsify:2.0.1'//刷新控件-虚拟回弹占位\nMagicIndicator(自定义TabLayout) 'com.github.hackware1993:MagicIndicator:1.6.0'\nMultiType(RecyclerView多类型适配器) 'me.drakeet.multitype:multitype:3.5.0'\nBanner(基于RecyclerView) 'com.youth.banner:banner:2.1.0'\nSVGA(动画) 'com.github.yyued:SVGAPlayer-Android:2.5.3'\nTBS(腾讯X5内核) 'com.tencent.tbs.tbssdk:sdk:43967'\n```","tags":["持续更新"],"categories":["Android"]},{"title":"不透明度 16进制表示","url":"/2021/01/31/常用透明度16进制表示/","content":"不透明度|16进制值\n:-:|:-\n100%|FF&ensp;不透明\n95%|F2\n90%|E6\n85%|D9\n80%|CC\n75%|BF\n70%|B3\n65%|A6\n60%|99\n55%|8C\n50%|80&ensp;半透明\n45%|73\n40%|66\n35%|59\n30%|4D\n25%|40\n20%|33\n15%|26\n10%|1A\n5%|0D\n0%|00&ensp;全透明","tags":["基础知识"],"categories":["前端"]},{"title":"第一个博客起好了233","url":"/2020/09/10/FirstBlog/","content":"一开始想搞WordPress，结果遇到了成吨的坑，然后从团子那里了解并且搞成了Hexo。  \n不用起服务器还是挺香的23333毕竟没有后台项目，不然空烧服务器也太浪费了。","tags":["Hexo"],"categories":["日常随笔"]}]